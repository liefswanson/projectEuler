mid sized question
                            75
                          95  64
                        17  47  82
                      18  35  87  10
                    20  04  82  47  65
                  19  01  23  75  03  34
                88  02  77  73  07  63  67
              99  65  04  28  06  16  70  92
            41  41  26  56  83  40  80  70  33
          41  48  72  33  47  32  37  16  94  29
        53  71  44  65  25  43  91  52  97  51  14
      70  11  33  28  77  73  17  78  39  68  17  57
    91  71  52  38  17  14  91  43  58  50  27  29  48
  63  66  04  68  89  53  67  30  73  16  69  87  40  31
04  62  98  27  23  09  70  98  73  93  38  53  60  04  23

small example
   7
  3 6
 8 6 4
2 5 1 7

3->7->4->9 => 23

possible approaches:
_____________
brute force : 
O(product (connections from i-1 to i))
=O(n!)

_______________
iterative dfs : 
O(idfs) > O(bruteforce) as node is on bottom tier
____
A* : 
O(A*) approx O(bruteforce) in worst case?
take each node and replace with (100-node_value) 
heuristic_1 = sum (min each level) //appears to be the only admissible in the general case
heuristic_2 = result from recursive subtriangles (next algorithm)
___________________________________________________
recursively find the largest path in sub triangles : 
O(sum 2(connections from i-1 to i))	
= O(n*(n+1))
approx O(n^2)
where n = number of connections going to bottom layer
_________________________________________________________________________________________________
recursively find largest path in subtriangles, find which of these paths is most significant, and use A* to link between the largest path segments? (This might not work)
_______________________________________________________________________
work backwards, and add the maxiumum of the two children to each parent: 
O(sum 2(connections from i-1 to i))
= O(n*(n+1))
approx O(n^2) 
where n = number of connections going to bottom layer
Algorithm from: http://stackoverflow.com/questions/20303553/max-path-triangle-python
this is a simple implementation of recursive subtriangles

=======   
A* test
=======
   3
  /\
  7 4
 /\/\
 2 4 6
/\/\/\
8 5 9 3
\ \ / /
 goal!

   7
  /\
  3 6
 /\/\
 8 6 4
/\/\/\
2 5 1 7
\ \ / /
 goal!

dist heuristic = 7 + 3 + 4 + 1 = 15
actual path = 7 + 3 + 6 + 1 = 17

7->3 = 10
7->6 = 13

7->3->8 = 18 (too large place in priority queue)
7->3->6 = 16 (queue it)

7->6->6 = 19 (queue it)
7->6->4 = 17 (queue it)

pull heighest priority
7->3->6
7->3->6->1 = 17 (queue it) (this is the answer, but we don't know that yet)
7->3->6->5 = 21 (queue it)

pull heighest priority
7->6->4 and 7->3->6->1 have the same priority
7->3->6->1 is longer, thus is would be logical it hade higher priority...

7->3->6->1->goal! (solution found)
what should the value of goal! be?... 0? null?
or... should we denote the goal by path length = height of triangle?

final answer:
7->3->6->1 => 17
transform back into original question parameters
(10-7)->(10-3)->(10-6)->(10-1) => 4*10 - 17
3->7->4->9 => 23

========================
stack overflow algorithm
========================
   7
  3 6
 8 6 4
2 5 1 7

   7
  3  6
13 11 11

  7
16 17

23

This algorithm is similar to recursively finding the largest path in a subtriangle

However, this algorithm does not preserve the path
If I wanted to get the path back, it may be possible to use A* to retrive it using this as the heuristic

We can build the path by tracking the nodes used up to that point as we go up tiers!
