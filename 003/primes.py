#Copyright (C) 2014 Lief Swanson

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

#Author: Lief Swanson
#URL: https://github.com/liefswanson


#object used to contain a prime number
class Prime(object):
    
    #constructor
    def __init__(self, value):
        self.value = value
        self.distanceToNextMultiple = value
        
    #tostring
    def __str__(self):
        return str(self.value)
        
    #used to generate the next piece of the prime's generating function
    def generate(self, iterations=1):
        self.distanceToNextMultiple -= iterations

        if self.distanceToNextMultiple <= 0:
            self.distanceToNextMultiple += self.value
            
    #check the value at the current part of the prime's generating function
    def checkPrimality(self):
        if self.distanceToNextMultiple == self.value:
            return False
        else:
            return True

#generates a list of primes of size "length"
def genPrimes( cap ):
    #initialize arrays for both the primes up to sqrtn and after sqrtn
    activePrimes = []
    inactivePrimes = []
    #populate arrays to avoid indexing errors during the main loop
    activePrimes.append(Prime(3))
    inactivePrimes.append(Prime(5))
    #output the first three primes to the console, otherwise output starts at 7
    print (2)
    print (3)
    print (5)


    #this loop skips all even numbers
    #removing the need to check against 2

    #7 is the next odd number after 5 which is the last prime added to our known primes (one i added manually)
    n=7
    #skip size between primality checks on n
    iterationSize = 2
    #run generate manualy on Prime(3) because we added 5 manually
    #without this, the generating function for 3 would be off by one run of the main loop below
    activePrimes[0].generate(2)
    
    i = 3
    while i < cap:
        #give an initial optimistic value for the primality of the number we are looping at
        isPrime = True

        #debughead(n)

        #check the truth values generated by all the prime generating functions
        #run logical and across the whole set
        #if the result is true, the number is infact prime
        for prime in activePrimes:
            prime.generate(iterationSize)
            isPrime = isPrime and prime.checkPrimality()
            #debugbody(isPrime)

        #debugtail()
        
        #check the value of the first prime in inactive primes
        #determine if it needs to be added to active primes
        #is it the square root of n?
        if inactivePrimes[0].value**2 == n:
            activePrimes.append( inactivePrimes.pop(0) )
            #adding a new prime in this way means sqrt(n) is the value added
            #thus it is not prime
            isPrime=False

        #if the result of the logical and was "True" the number being queried was prime
        if isPrime:
            #add the value to our list of primes
            inactivePrimes.append( Prime(n) )
            #make sure to output the newly found prime to the console
            print(n)
            i+=1

            
        n+=iterationSize

    return [Prime(2)] + activePrimes + inactivePrimes


def genPrimesUntil( cap ):
    #initialize arrays for both the primes up to sqrtn and after sqrtn
    activePrimes = []
    inactivePrimes = []
    #populate arrays to avoid indexing errors during the main loop
    activePrimes.append(Prime(3))
    inactivePrimes.append(Prime(5))
    #output the first three primes to the console, otherwise output starts at 7
    print (2)
    print (3)
    print (5)


    n=7
    iterationSize = 2
    activePrimes[0].generate(2)
    
    while n < cap:
        isPrime = True

        #debughead(n)
        for prime in activePrimes:
            prime.generate(iterationSize)
            isPrime = isPrime and prime.checkPrimality()
            #debugbody(isPrime)

        #debugtail()
        
        if inactivePrimes[0].value**2 == n:
            activePrimes.append( inactivePrimes.pop(0) )
            isPrime=False

        if isPrime:
            inactivePrimes.append( Prime(n) )
            print(n)
            
        n+=iterationSize

    return [Prime(2)] + activePrimes + inactivePrimes

#prints the first number and the truth values for 1 and 2
def debughead(n):
    print (str(n))
    print ("11", end="")

def debugbody(isPrime):
    if isPrime:
        print("1", end="")
    else:
        print("0", end="")

def debugtail():
    print("")


